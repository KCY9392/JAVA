package com.kh.chap02_abstractAndInterface.part01_interface.model.vo;

public interface Basic {
// 인터페이스
	
// [표현법]
// [접근제한자] interface 인터페이스명 { }	
	// abstract보다 많이 사용한다.
	
	
	/*
	 * 인터페이스
	 *  - 상수필드와 추상메소드로만 이루어진 추상클래스의 변형체
	 *  - 인터페이스에서 필드는 무조건 상수필드이다.
	 *  - 인터페이스에서 메소드는 무조건 추상메소드이다.
	 *  - 무조건 구현해야하는 게 있을 때, 인터페이스를 만들어서 상속하게 된다.
	 *  - 인터페이스는 다중 상속을 허용한다.
	 *    (결국 메소드에 대한 정의만 하고 있어서, 메소드가 겹치더라도 최종 구현부분은 구현클래스에서 이루어질 것이기 때문에, 다중상속이 가능하다.)
	 *  - 추상클래스와 다르게 좀 더 강한 규칙성, 강제성을 가지는 게 인터페이스이다.
	 *  
	 *  
	 *    추상클래스와 인터페이스
	 *    
	 *    1. 공통점
	 *    
	 *     - 객체 생성은 안되나 "참조변수"로서 사용이 가능하다.(다형성 적용가능)
	 *     
	 *     - 상속(구현)하는 클래스에 추상메소드를 구현하도록 강제한다.
	 *     
	 *    2. 차이점
	 *    
	 *       > 추상클래스는 클래스내에 인스턴스 변수, 메소드를 생성이 가능하고,
	 *         추상메소드가 포함되었거나 abstract키워드로 클래스가 정의되어있고,
	 *       
	 *       > 인터페이스는 인스턴스변수, 메소드 생성이 불가능하며 
	 *         모든변수는 상수필드, 모든 메소드는 추상메소드로 정의 되어있다.
	 *     
	 *     - 존재하는 목적이 다르다.
	 *     
	 *       > 추상클래스는 "추상클래스를 상속받아서 기능을 이용하고, 클래스를 확장하는 데 목적"이 있다.
	 *       
	 *       > 인터페이스는 클래스의 기능(함수)구현을 강제하기 위해 사용한다.
	 *       //똑같은 메소드를 사용하게 하기위해서
	 *       즉, 구현을 강제함으로써 "구현객체의 같은 동작을 보장"할 수 있다.
	 *       
	 *       
	 * extends와 implements
	 * 	- 클래스간에 상속 관계일 때 : 클래스명 extends 클래스명 (단일상속만 가능)
	 * 	- 클래스와 인터페이스의 구현 관계일 때 : 클래스명 implements 인터페이스명[,인터페이스명,인터페이스명,...] (다중구현가능)
	 * 	- 인터페이스간에 상속 관계일 때 : 인터페이스명 extends 인터페이스명 , 인터페이스명 (다중상속가능)
	 * 
	 */
	
	
	/* public static final */ int NUM = 10;
	// 인터페이스 필드는 항상 static final 키워드 포함한다.
	// 얘도 public static final를 생략해도 자동으로 상수필드가 된다.
	// 인터페이스에서는 상수 필드만 정의할 수 있기 때문에 앞의 public static final 키워드가 생략가능하다.
	
	
	/* public abstract */void eat();

	/* public abstract */ void sleep();
	// public abstract를 생략해도 자동으로 추상화메소드가 된다.
	// 인터페이스에서는 추상메소드만 정의할 수 있기 때문에 앞의 public abstract키워드가 생략가능하다.
	
	
}
